---
title: OOP-(3)--预解析
tags: 
- 面向对象
categories:
- JS
- JS_OOP
---

## 预解析的概念
### 什么是预解析
> js代码在执行之前,对代码进行的翻译解释,可以减少代码在执行时出现异常

### 为什么需要预解析

#### 编译性语言
> 编译型语言: C, C++, C#, Java ...需要一个 "翻译" 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ).然后存储成可执行文件. 也就是会提前翻译好, 运行时直接执行得到结果

#### 解释性语言
> 解释型( 脚本型 ): JavaScript, SQL, ... 代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, 再执行一句代码.

#### 为什么需要预解析

> 代码在执行之前, 快速的 "预览" 一遍,对错误部分进行暴露, 那么可以尽可能提高执行时的效率.

## 预解析的特点

> 预解析的过程中完成代码申明部分的标记与变量作用域的设定

### 什么是申明

> 寻找标识符进行标记,使js执行引擎知道当前环境有哪些东西可用

### 变量申明

	语法: 	var 变量名;
	目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.
	
	var a; // 申明变量a 值是undefined
	var b = 123; // 申明变量b 同时在执行时赋值123;
	
#### 申明提升

	if('a' in window){
		var a = 123;
	}
	
	console.log(a);
	
	// 分析:
	//	1.读取所有的代码( 字符串 ). 包含每一个字节, 每一个数据. 但是 "只留意" var
	// 	2.判断 var 后面紧跟的名字是否被标记. 如果没有, 则标记上. 
	//		如果已标记, 则忽略.	表示在当前环境中已经有该变量了.
	// 	3.读取完毕后, 代码再从头开始, 从上往下, 从左至右一句一句的执行代码.
	//		执行 'a' in window. 很显然当前环境中已有变量 a, 所以结果为真.

### 函数申明 

#### 函数的定义形式

- **声明式**:	

		function func () {
			console.log( '使用声明式定义' );
		}
					
- **表达式式( 匿名函数, 字面量函数, lambda 函数 )**:

		var func = function () {
			console.log( '使用表达式式定义' );
		};
		
		/*也可以带有名字*/
		var func = function fn(){
			console.log('表达式式函数');
		};
		
#### 两种形式定义函数的特点

> **函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.**
> **函数声明是独立于代码执行的. 代码在执行的时候, 声明部分已在预解析阶段处理完毕.所以可以先调用后申明.**

> **表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.**

#### 表达式定义函数的注意点

	var f1 = function f2 () {
		console.log( '带有名字的  函数表达式' );
		console.log( f2 );
	};

	// 当函数声明语法嵌入表达式环境中, 会自动进行转换, 将转换成函数表达式.
	// 1> 引用函数的规则还是使用变量赋值, 所以外部可以使用该名字调用函数.即可以使用f1调用函数
	// 2> 函数表达式带有名字, 该名字只允许在函数内部使用. 属于局部作用域. ( IE8 除外 )即f2只能在f2函数内部使用
	// 3> 带有名字的函数表达式, 函数的 name 属性即为该名字,即函数的name为f2

### 什么叫表达式

> 1.将运算符与操作数连接起来的式子.

> 2.存在结果的代码单元(不包括语句).
	
	var a;		// 声明, 不是语句, 也没有结果
	123			// 字面量, 有值, 是表达式. 是常量表达式
	a = 123		// 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.
	
### 函数申明和变量申明同时出现的注意点

> 声明变量, 是告诉解释器当前环境可以使用该名字了.

> 声明函数, 是告诉解释器, 除了可以使用该名字, 该名字还表示一个函数体.

#### 先var 后 function

	var num;
	function num(){
		
	}
	console.log(num); // 打印函数体
	
	// 先 var num; 后 function num ...
	// 首先告知解释器有 名字 num 了
	// 后面是函数声明. 由于已经有 num 名字可以使用了, 所以就不再告诉解释器可以使用 num
	// 而是直接将 num 与函数结合在起义.
#### 先function 后 var

	function num(){};
	var num;
	console.log(num); // 打印函数体
	
	// 先 function num ... 后 var num;
	// 一开始已经有 num 了, 而且是函数. 所以后面的 var num; 属于重复声明.

### 特例

	if ( true ) {
		function foo() {
			console.log( true );
		}
	} else {
		function foo() {
			console.log( false );
		}
	}
	foo();
	
	// 在早期的浏览器中( 2015 年前) 所有的浏览器( 除了火狐 )都是将其解释为声明 : false
	// 但是现在的运行结果, 得到: true. 表示 if 起到了作用
	
	/******************************/
	
	if ( true ) {
		function foo1() {
			console.log( true );
		}
	} else {
		function foo2() {
			console.log( false );
		}
	}
	foo1();
	// foo2();  // error: foo2 is not function. 已定义, 但是函数为被指向

	// 好比: var foo1 = function foo1 () { ... }

	// 虽然这两个函数不是声明, 但是也不能解释成函数表达式. 如果是函数表达式 foo1 与 foo2 只能在函数内部使用.
