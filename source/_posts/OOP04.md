---
title: OOP-(4)--作用域
tags: 
- 面向对象
categories:
- JS
- JS_OOP
---

## 词法作用域
### 什么叫作用域

> 变量可以使用 到 不能使用的范围

### js的词法作用域

>  js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 而js只有函数可以限定范围. 其他均不能限定访问范围. 所以实际上词法作用域也可以称作函数作用域.

### 词法作用域特点

> 1. 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.
>
> 2. 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.
> 
> 3. 所有变量的访问规则, 按照预解析规则来访问
> 
> 4. js中变量的作用域链与定义时的环境有关，与执行时无关。

### 案例

#### 案例01

	var num = 123;
	function f1 () {
		console.log( num );
	}
	function f2 () {
		console.log( num );
		var num = 456;
		f1();
		console.log( num );
	}
	f2();

	1> 读取代码预解析. 得到 num, f1, f2
	2> 逐步的执行代码
		1) 赋值 num = 123;   注意 f1 和 f2 由于是函数, 所以也有数据.
		2) 调用 f2.
			进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num
			执行每一句代码
			-> 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined
			-> 赋值 num = 456
			-> 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否有函数的声明. 如果有直接使用. 如果没有, 则在函数外面找, 看是否有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数
			-> 跳入 f1 函数中. 又要解析一次. 没有得到任何声明.
			-> 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. 
				函数调用结束, 回到 f2 中.
			-> 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456.
	
	
#### 案例02

	(function ( a ) {
		console.log( a );
		var a = 10;
		console.log( a );
	})( 100 );

	拆解
	( 函数 ) ( 100 )
	第一个圆括号就是将函数变成表达式
	后面一个圆括号就是调用该函数

	注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明
	function ( a ) { ... }
	其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明.

	由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效.
	所以上面的代码, 等价于
	var func = function ( a ) {
		console.log( a );			// => 100
		a = 10;
		console.log( a );			// => 10
	}
	func( 100 );
	
#### 案例03

	(function ( a ) {
		console.log( a );
		var a = 10;
		console.log( a );
		function a () {
			console.log( a );
		}
		a();
	})( 100 );


	1> 直接调用
	2> 进入到函数中, 已有声明 a 并且其值为 100
	3> 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. 
		1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了
		2) 让 a 指向函数. 相当于
			var a;
			function a () {}
			...
	4> 开始逐步执行每一句代码
		1) 打印 a. 所以打印函数体
		2) 赋值 a = 10
		3) 打印 a, 打印出 10
		4) 调用 a, a已经被赋值为10,不在是函数体, 所以报错 error: a is not function
			
## 作用域链

> 链其实指的一种访问规则,作用域链就是指作用域的访问规则

### 绘制作用域链的规则

	1. 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.
	2. 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.
	3. 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.
	4. 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.
	5. 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推...

### 分析代码执行

	1. 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化
	2. 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.
	3. 如果找到变量, 直接使用. 如果没有找到变量 在上一级, n - 1 级中查找.
	4. 一直找下去, 直至到 0 级链. 如果 0 级链还没有就报错. xxx is not defined.

### 经典面试题


	var  arr = [ { name: '张三1' }, 
				 { name: '张三2' }, 
				 { name: '张三3' }, 
				 { name: '张三4' } ];

	// 利用循环, 添加方法, 在方法中打印 name
	for ( var i = 0; i < arr.length; i++) {
		// arr[ i ] 绑定方法
		arr[ i ].sayHello = function () {
			// 打印名字
			console.log( 'name = ' + arr[ i ].name );
		};
	}

	for ( var i = 0; i < arr.length; i++ ) {
		arr[ i ].sayHello();
	}

	// 打印结果?
